'''
Project in a Box Introduction to Python: Machine Learning Edition

Note: The triple apostrophes are multi-line comments. They need to be done in pairs or else your code will not compile correctly. Hashtags are for
single line comments. These do not need to be done in pairs. The compiler does not run comments.

Note: Throughout this file, you will see a ton of "# %%" pairs above and below code blocks. They represent a single cell. In Spyder, you can run each cell
individually by clicking within it and pressing CTRL+RETURN. For our purposes, we want to run each cell one by one. We do not want to run the entire file.

Note: Outputs and inputs are shown on the console in the bottom right. You can see the variables and plots generated by the code in the top right.
'''

'''
=============================================================================
Hello, World!
=============================================================================
'''
# %%
# Let's try to run the most common code out there, a print statement. 
# print() will print the value inside the parenthesis
print("Hello, World!")

# Try to print your name onto the terminal
# %%

# %%
# input() prints the value inside the parenthesis
# it also returns a string input from the terminal
# the variable string is assigned the value returned from input()
string = input("Type \"Hello World!\"\n")           # /" is needed to print " in the string and \n creates a new line
print("Your input -> " + string)

# Try typing something and see what happens
# %%

'''
=============================================================================
Operators
=============================================================================
Throughout this tutorial, you will need to use the different operators that Python allows.
They are pretty self-explanatory so there isn't much to be said. Let's list them below.
Arithmetic Operators:
+ is addition. You can do x + y
- is subtraction. You can do x - y
* is multiplication. You can do x * y
/ is division. You can do x / y
% is modulo. You can do x % y (It is the same as division but it returns the remainder instead.)
// is floor division. You can do x // y (It is the same as division but it returns the result rounded down to nearest integer)
** is exponent. You can do x ** y

Logical Operators:
and returns True if both statements are true. Ex: x>5 and x<9
or returns True if one of the statements is true. Ex: x>5 or x<2
not returns False if is result is True. Ex: not(x>5 and x<9)

Comparison Operators:
== is equal to. You can do x == y.
!= is not equal to. You can do x != y
> is greater than. You can do x > y
>= is greater than or equal to. You can do x >= y
< is less than. you can do x < y
<= is less than or equal to. You can do x <= y

Assignment operators:
= sets a variable to a value. You can do x = 1
+= adds a number to itself. You can do x += 1 (which is the same as x = x + 1) (You can do this with all arithmetic operators)

There are other operators, such as bitwise operators, to be listed but those shown above are the basic ones you'll most likely need.
'''

'''
=============================================================================
Variables
=============================================================================
'''
# %%
# Here is a basic intro into variables within Python.
x = 5
y = "Karen"
print(x)
print(y)
# %%

# %%
# As you can see, variables do not need to be a specific type (integer,string, etc.)
# If you want, you can even change the variable type.
x = 5
print(x)
print(type(x))
x = str(x)
print(x)
print(type(x))
# We just changed the variable from an integer to a string.
# %%

# %%
# Now let's get into possible names for variables. Python has certain rules for this.
# The below example will throw syntax errors when run. It will specify the name which caused it.
# Correct names:
variable = "Karen"
vari_able = "Karen"
_vari_able = "Karen"
variAble = "Karen"
VARIABLE = "Karen"
variable2 = "Karen"
# Incorrect names:
2variable = "Karen"
vari-able = "Karen"
vari able = "Karen"
# %%

# %%
# You can assign values to your variables one by one or you can do it all at once if need be.
x, y, z = 1, "Karen", "Manager"
print(x)
print(y)
print(z)
# or if you want multiple variables to have the same value:
x = y = z = "Karen"
print(x)
print(y)
print(z)
# %%

# %%
# Manipulating variables is pretty simple as well but it does have it's rules as well.
x = "I want to"
y = " speak to the manager."
z = x + y
print(z)
# It works the same for numbers.
x = 20
y = 30
print(x + y)
# Unfortunately, you can't combine two data types together.
x = "Karen is "
y = 50
print(x + y)
# But what you can do simply change the variable type to fit your needs. Comment out the previous 3 lines and
# uncomment the next 4 lines.
#x = "Karen is "
#y = 50
#y = str(y)
#print(x + y)
# %%

'''
We will also go over global variables in the Functions section of this tutorial. If the variable is outside of
a function, it is considered a global variable, which means it can be used inside and outside functions.
If the variable is inside a function, it can only be used inside that particular function.
'''

'''
=============================================================================
Conditional Statements
=============================================================================
'''
# %%
# assign magicNumber and inputNumber an integer value. Try changing them and see what happens
magicNumber = 10
inputNumber = 10

# if statements evaluate the expression after it. If the expression is true, then the code under it runs.
if inputNumber == magicNumber:
    print(str(inputNumber) + " is the magic number!")       # str() converts an int value to a string value


# When the if statement does not run, the else statement will run. There can only be 1 else statment for every if statment
# else statements are optional. It is not needed to make an if statement work properly.
else:
    print(str(inputNumber) + " is not he magic number.")


# Try changing the code so that you assign inputNumber a value from the terminal.
# %%

# %%
# assign inputNumber a user input
inputNumber = int(input("Enter a number: "))    # int converts a string value into an int value

if inputNumber < 0:
    print("This is a negative number.")

# elif is short for else if
# Similar to an else statement, elif statements will only run when the if statement did not run.
# Similar to an if statement, elif statements will only run when the expression after it evaluates to True.
# You can have multiple elif statements after an if statement. When an elif statement runs, all elif and else statements after it will not run.

elif inputNumber > 0:
    print("This is a positive number.")

else:
    print("This number is 0.")
# %%

'''
=============================================================================
Lists
=============================================================================
'''
# %%
# Lists are a data type that can store multiple values written as a comma separated list.
numbers = [1, 2, 3, 4, 5]
print("Here is the list: " + str(numbers))

# You can access a specific value in the list by indexing
# To index a list, you put the name of the list followed by the index of the value you want in [].
# Indexing in python starts with 0, so the first number has an index of 0
print("Printing the 1st number: " + str(numbers[0]))
print("Printing the 2nd number: " + str(numbers[1]))
print("Printing the 3rd number: " + str(numbers[2]))
print("Printing the 4th number: " + str(numbers[3]))
print("Printing the 5th number: " + str(numbers[4]))

# You can also have negative indexes to get values from the end of the list
print("Printing 1st number from the end: " + str(numbers[-1]))
print("Printing 2nd number from the end: " + str(numbers[-2]))
print("Printing 3rd number from the end: " + str(numbers[-3]))
print("Printing 4th number from the end: " + str(numbers[-4]))
print("Printing 5th number from the end: " + str(numbers[-5]))



# Lists can be added on to expand it
numbers = numbers + [6, 7, 8, 9, 10]
print("Here is the new list: " + str(numbers))

# Add some numbers to the list and print the numbers that you added.
# %%

# %%
# Methods are specific functions that are used for data types
# Methods are called with variableName.methodName()
# Here are some methods used for lists
# Take some time and read through the code to really understand what is going on in each section of the code.

# copy() - returns a copy of the list
numbers = [9, 1, 0, 7, 4]
numbersCopy = numbers.copy()
print("copy()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# append() - adds a single element to the end of the list
numbers.append(5)
print("\nappend()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# extent() - adds the elements of a list to the end of the list
numbers.extend([3, 6, 8, 2, 7])
print("\nextend()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# insert() - inserts an element at a specific index
numbers.insert(2, 7)
print("\ninsert()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# index() - returns index of the first element with a specified value
print("\nindex(7): " + str(numbers.index(7)))
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# remove() - removes the first element with a specifed value
numbers.remove(7)
print("\nremove(7)")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# pop() - removes an element at a specific index
numbers.pop(3)
print("\npop()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# sort() - sorts the list
numbers.sort()
print("\nsort()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# reverse() - reverses the list
numbers.reverse()
print("\nreverse()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))

# clear() - clears the list
numbers.clear()
print("\nclear()")
print("Original: " + str(numbers))
print("Copy:     " + str(numbersCopy))
# %%

'''
=============================================================================
Loops
=============================================================================
'''
# %%
# Loops are used when you need to repeat code many times. If you want a user to input a list of numbers, you can use a loop to ask them for inputs.

numbers = []                                                # initializing an empty list
print("Entering a negative number will end the program.")
newNumber = int(input("Enter a non-negative number: "))     # initializes the variable for the loop
                                                            # if the first number entered is negative
                                                            #   then the loop will not run

# while loops repeats its body code as long as the expression after it is true
while newNumber >= 0:
    numbers.append(newNumber)
    newNumber = int(input("Enter a non-negative number: "))

print("Here is your array: " + str(numbers))


# for loops are used when you need to repeat a body of code over a range of numbers, such as each index of a list
# len() is used to find the number of items within a list or the number of characters in a string
# range(x) creates a range of values from 0 to (x - 1)
# range(x, y) creates a range of values from x to (y-1)
# range (x, y, z) creates a range of values from x to (y-1) in increments of z
for idx in range(len(numbers)):             # try changing the range to and see which numbers are printed
    print("Number " + str(idx + 1) + ": " + str(numbers[idx]))

# %%

# %%
# declare list of numbers
numbers = [1,6,5,3,4,9,7,6,2,1,13,65,7,84,95,24,31]

# break statement is used to terminate a for or while loop early

# this loop will terminate when it finds the first value of 7
for idx in range(len(numbers)):
    print("Index " + str(idx) + " is not 7.")
    if numbers[idx] == 7:                       # when the number 7 is found, break out of the loop
        print("The first index of 7 is " + str(idx))
        break

print("Check with index()")
print("numbers.index(7): " + str(numbers.index(7)))


# continue statements are used to go to the next iteration of the loop
for idx in range(len(numbers)):
    if numbers[idx] % 2 == 0:
        print("Index " + str(idx) + " is an even number.")
        continue
    print("Index " + str(idx) + " is an odd number.")
# %%

# %%
# Challenge 1
# Use a for loop to calculate the sum and average of the inputed list of numbers
# Make another for loop to calculate the sum and average of every even index and every odd index of the list
# Complete this challenge within this cell.

# %%

'''
=============================================================================
Functions
=============================================================================
'''
# %%
# A function can be created by using "def"
def test_function():
    print("Hello, World!")
    
# You have just created a function but now let us test it out.
test_function()
print("Goodbye!")

# As you saw in the terminal, we were able to see our function execute and print our message.
# It works the same as any normal code being run.
# %%

# %%
# Now let's start passing some values into our function.
# As a side note, Python uses the words values, parameters, and arguments interchangeably.
def name_function(person):
    print("My name is " + person)

name_function("what?")
name_function("who?")
name_function("Slim Shady.")

# In this case, we made sure that the value we are passing through the function was the proper type
# for the print statement. If we didn't do that, the program would throw a syntax error. If we wanted to,
# we could have made sure the value would always be a string if we had put str(person) instead of just
# person in the print statement.
# %%

# %%
# If you want to pass more than one argument through your function, you have to remember to call that
# function with the same number of arguments. Otherwise, you will get an error when you try to run it.
def test_function(name, age):
    print("My name is " + name + " and my age is " + age)

test_function("Slim Shady")

# Now let's try it with the correct number of arguments. Uncomment the line below.
#test_function("Slim Shady", "48")

# Additionally, the order they are written in is important. It must match the ordering in the function.
# Now let's test the order importance. Uncomment the line below.
#test_function("48", "Slim Shady")

# See how the order is mixed up? We can make it so that the order no longer matters. Uncomment the line below.
#test_function(name = "Slim Shady", age = "48")
#est_function(age = "48", name = "Slim Shady")
# %%

# %%
# You can also set an argument to a default value if you end up not passing anything into the function.
def test_function(name = "Slim Shady"):
    print("My name is " + name)

test_function("Karen")
test_function()
test_function("Stan")
# %%

# %%
# You can pass any data type through a function as an argument. You can do integers, strings, lists, etc. Let's also
# check the type of variable we will be pushing through as a sanity check.
num_list = ["12", "24", "36"]
def print_list(listofstuff):
    for x in listofstuff:
        print(x)

print(type(num_list))
print_list(num_list)

def print_numbers(num1, num2, num3, num4):
    print(num1)
    print(num2)
    print(num3)
    print(num4)

print(type(3))
print_numbers(3, 0, 0, 5)
# %%

# %%
# If you want to implement variables within your function (local variable), it works the same as outside.
x = "Straight Outta Compton"
def print_var():
    x = "8 Mile"
    print(x)

print_var()
print(x + " is a good movie.")
# %%

# %%
# You must declare a global variable if you wish to change a global variable within a function.
# Uncomment the first line of the function to fix this bit of code so it prints out Slim Shady instead..
x = "Marshall Mathers"
def my_func():
    #global x
    x = "Slim Shady"

my_func()
print("My name is " + x)
# %%

# %%
# You can also have a function return a value instead of changing a variable.
def return_func(a):
    return 10 + a

print(return_func(10))

# You can also return a boolean value of True or False.
def return_func_bool(a):
    if a >= 0:
        return True
    else:
        return False
    
print(return_func_bool(20))
# %%

# %%
# It is also possible to implement function recursion within Python. This is when a function can call
# itself. It is very easy to create mistakes in your code when doing this so you must be very careful.
# In the example below, we are finding the factorial of a number.
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x - 1))

z = 3
print("The factorial of " + str(z) + " is " + str(factorial(z)))
# Essentially, the function call ends up looking like this:
# 1st call: factorial(3)
# 2nd call: 3 * factorial(2)
# 3rd call: 3 * 2 * factorial(1)
# final return: 3 * 2 * 1
# %%

# Now let's do some challenges to test your comprehension. Simply fill out the function and run the cell. The print statement is there to give a hint
# for how it should be done but you don't have to follow it if you don't want to.
# %%
# Challenge 2: Create a function that checks whether a string argument is a palindrome. The print statement will check if that string is a palindrome.
def check_string(sentence):
    

print(check_string("mrowlatemymetalworm"))
# %%

# %%
# Challenge 3: Create a function that checks whether a number is prime or not. The print statment is checking if 4 is a prime number.
def check_prime(num):
    

print(check_prime(4))
# %%

# %%
# Challenge 4: Create a function that displays the Fibonacci sequence. We want to display up to the
# nth term of the sequence. The print statement is set to print the first 10.
def fib_seq(max_num_len):
    

for x in range(10):
    print(fib_seq(x))
# %%

'''
=============================================================================
Classes and Methods
=============================================================================
'''
# %%
# Essentially, Python is an object oriented programming language. Hence, everything in Python is pretty much an object
# with it's own methods.
# First some definitions.
# An object is simply a collection of data (variables) and methods (functions) that act on said data.
# A class is essentially a blueprint for said object.
# Let's make a simple class to start with.
class Bandit:
    health = 5
    stamina = 3
    
    def attack(self):
        print("Skyrim belongs to the Nords!")
        self.stamina -= 1
        
    def defend(self):
        print("Mercy! I yield!")
        self.stamina += 1
        if(self.health < 5):
            self.health += 1
        
# The reason we pass the "self" parameter in the internal function is because it represents the instance of the class.
# With that, you can access the class itself. You don't have to use self if you don't want to. You can use some other
# word but its just the common way that everyone does it.

# Now let's use this class and show it off.
john = Bandit()                                         # Create an object based on our Bandit class
john.attack()                                           # Have our "bandit" attack something
print("John's stamina is " + str(john.stamina))         # Show off the stamina of our bandit
john.defend()                                           # Have our "bandit" defend
print("John's stamina is " + str(john.stamina))         # Show off the stamina of our bandit
print("John's health is " + str(john.health))           # Show off the health of our bandit
# We can see that the attack and defend functions are the methods of the Bandit class. By calling the method
# through our created object, we can use the functions within our created class.
# %%

# %%
# Now what if we want to define how much health and stamina our Bandit has at initialization?
# Let's reconfigure our class to take that into account.
class Bandit:
    def __init__(self, health, stamina):
        self.health = health
        self.stamina = stamina
    
    def attack(self):
        print("Skyrim belongs to the Nords!")
        self.stamina -= 1
        
    def defend(self):
        print("Mercy! I yield!")
        self.stamina += 1
        if(self.health < 5):
            self.health += 1
        
john = Bandit(10,5)                                     # Create an object based on our Bandit class. We will also give a custom health and stamina level
carl = Bandit(5,3)                                      # Create a second "bandit" with different health and stamina
print("John will begin to move.")
john.attack()                                           # Have our "bandit" attack something
print("John's stamina is " + str(john.stamina))         # Show off the stamina of our bandit
john.defend()                                           # Have our "bandit" defend
print("John's stamina is " + str(john.stamina))         # Show off the stamina of our bandit
print("John's health is " + str(john.health))           # Show off the health of our bandit
print("Carl will begin to move.")                       # Have our second bandit do stuff
carl.attack()
print("Carl's stamina is " + str(carl.stamina))
carl.defend()
print("Carl's stamina is " + str(carl.stamina))
print("Carl's health is " + str(carl.health))
# %%

# You can continue to add on and tinker with this class if you would like. You can try to pass an argument through attack() in the class definition
# so you can maybe change what the voice line will be or how much stamina is lost. Its your class so you get creative with it if you like.

'''
=============================================================================
File Handling
=============================================================================
'''
# %%
# Python has a couple functions dedicated to manipulating files.
# Let's go over opening a file first.
# The function for this is: open()
# It takes two arguments: the filename and the mode
# The filename must be within " ".
# The mode can be 4 different types:
# - "r" which opens a file for reading and throws an error if filename does not exist (Default mode)
# - "a" which opens a file for appending and creates the file if filename does not exist
# - "w" which opens a file for writing and creates the file if filename does not exist
# - "x" which creates a file using filename and throws an error if the filename exists
# No need to run this cell since we won't be doing anything with the file yet.
f = open("demofile.txt", "r")
# which is the same as
f = open("demofile.txt")

# If need be, you can also specify whether you want to handle the file as a text file or a binary file.
# Use "t" for text (Default mode)
# Use "b" for binary
f = open("demofile.txt", "rt")
# which is the same as
f = open("demofile.txt")
# %%

# %%
# Now let's go over reading a file.
# To read a file, you must first open it using the methods above.
# The filename must be a file that is within the same directory the .py file is currently in.
# For our case, please make sure you go to the Files tab on the right and navigate to this file's folder.
# That way, Spyder knows where to look for demofile.txt
# After that, you use one of the methods from the open() function. It is called read().
# You simply append a .read() after whatever name you used for the open() function.
f = open("demofile.txt")
print(f.read())

# If the file you are trying to open is in a different directory, you must specify the file path.
# This ranges due to how everyone organizes their computer differently.
# For example, the file might be in a folder in the Desktop directory while this .py file is within
# a separate folder within the Desktop directory.
# The path might then be "C:\\Users\\username\\Desktop\\NotPythonFiles\\othertext.txt"
# %%

# %%
# By default, read() returns the entire file. But sometimes we don't want that. We can specify how
# many characters we want to read simply by inputting that as an argument in read().
f = open("demofile.txt")
print(f.read(6))
# %%

# %%
# If you want to read the file line by line instead, you can use readline() instead of read().
# If you want to read multiple lines, you can simply call readline() multiple times or you can simply
# loop through the file line by line using a for loop. Uncomment them one at at a time to see for yourself.
f = open("demofile.txt")
print(f.readline())
print(f.readline())
# for x in f:
    # print(x)
# You may notice that when using the readline() method, there is an extra newliine that is printed in
# terminal. This is because it also reads the "\n" newline character at the end of each line.
# %%

# %%
# Once you are done with a file, it is good practice to always close it. If you don't close the file,
# any changes made to it will not show. To do so, simply append a .close()
f = open("demofile.txt")
print(f.read())
f.close()
# %%

# %%
# As a side note, it is quite handy to use the "with" statement with file handling code. It makes the
# matter of handling the open/close status quite easy. We can replace the above example with the code
# shown below. After running the code within the "with" statement, the file will automatically close,
# ensuring there will be no bugs within your code related to that file opening.
with open("demofile.txt") as f:
    print(f.read())

# You can also open multiple files at once using this statement. You can access more data without
# having to worry about all the open files.
# Ex: with open("demofile.txt") as f, open("demofile2.txt") as g:
# %%

# %%
# Instead of reading a file, let's write to one.
# To do this, you must open the file using the proper mode: either append ("a") or write ("w")
# First let's append some content into the file using "a" mode.
f = open("demofile.txt", "a")
f.write("\nUse the Force, Luke.")
f.close()
# Now let's reopen the file to see our changes.
f = open("demofile.txt")
print(f.read())
f.close()
# %%

# %%
# Let us overwrite what is in demofile.txt using the write mode. I must reiterate this. Using "w" will
# OVERWRITE whatever was in the file before.
f = open("demofile.txt", "w")
f.write("Only a Sith deals in absolutes.")
f.close()
# Now we will reopen the file to see the changes we just made.
f = open("demofile.txt")
print(f.read())
f.close()
# %%

# Now let's do some challenges to test your comprehension. Create your code within the cell and run it to see if it works. Remember to keep your files
# within the same directory this file is in.
# %%
# Challenge 1: Write a file that has a list of your top 3 favorite movie lines. Check the file to see if it worked.

# %%

# %%
# Challenge 2: Combine two lines from two separate files and print them.

# %%

'''
=============================================================================
Python Libraries
=============================================================================
'''
# Libraries are sets of useful functions that eliminate the need to write your own code from scratch.
# There are over 100,000 Python libraries out there. We will only focus on a few popular libraries
# for our ML purposes today.
# NumPy - It's a library used for working with arrays. It also has some functions for matrices and
#         other linear algebra content. Even though Python already has lists, which are essentially
#         arrays, a numpy array is much faster and easier to work with. This has to do with how it
#         allocates the memory used by the array vs how lists are allocated.
# Here is how to import the library for use in your code.
# import numpy
# Or if we want to shorten the name to it's common alias np
# import numpy as np

# %%
# Since the NumPy library is made to work with arrays, let's do just that. You can either create a list
# and pass that through np.array() or simply input the list of data directly to create an array.
# We will create the list first so that you can see how NumPy changes the list into an array.
import numpy as np
list_1 = [2,4,5,6,8]
array_1 = np.array(list_1)
print(list_1)
print(type(list_1))
print(array_1)
print(type(array_1))
print(array_1.ndim)
# As you can see, the data type of list changes to that of an ndarray. We can also use .ndim to check
# the dimension of the array we created. In this case, it is still a 1D array so it is all good. There
# is no general array size limit but you are constrained by the amount of memory on your computer.
# %%

# %%
# If you are familiar with C programming, working with NumPy arrays should be fairly straightforward.
import numpy as np
array_1 = np.array([1,2,3,4,5])
print(array_1[0])
print(array_1[4])
# Accessing the array works the same if your array is bigger than 1D. Just take care of the extra coordinates. (x,y) is [y][x]
# If you are confused with how the indexing works, simply go to the Variable Explorer on the right and double-click on the array variable name.
# It'll show the index numbers for you.
array_2 = np.array([[1,2,3],[4,5,6]])
print(array_2)
print(array_2[0,0])
print(array_2[1,0])
print(array_2.shape)
# Now let's reshape the array.
array_3 = array_2.reshape((3,2))
print(array_3)
print(array_3[0,0])
print(array_3[2,0])
print(array_3.shape)
# As you can see, is it important to know the dimensions of your multi-dimensional arrays when indexing.
# Otherwise, you can end up making a mistake when grabbing data from a certain index.
# %%

# %%
# There will be some times when you need to create an array of data to work with as test data or something else.
# To do this, we can use a couple functions within the NumPy library.
# We can use .arange() to create an array of evenly spaced values within a given interval.
import numpy as np
array_1 = np.arange(10,21,2)
print(array_1)
array_2 = np.arange(10)
print(array_2)
# As you can see, the first array it creates starts from 10 and is incremented in steps of 2 all the way until 20.
# The second array it creates shows another way of using it.
# The first input to arange is the start number. If left blank, it defaults to 0.
# The second input is the stop number. The created array does not include this number. You must include it.
# The third input is the step size. If left blank, it defaults to 1.
# %%

# %%
# Since NumPy is useful for arrays, we can also take advantage of some matrix manipulation functions.
# Let's set up two practice matrices.
import numpy as np
array1 = np.array([[1,2],[3,4]])
array2 = np.array([[5,6],[7,8]])
print(array1)
print(array2)
# Now let's add them together.
print(np.add(array1,array2))
# How about dividing them?
print(np.divide(array1, array2))
# Let's check if we can transpose a matrix.
print(array1.T)
# %%%

# %%
# NumPy also has another very important functionality. It can create pseudo random numbers. If your project or code
# needs some sort of randomness in it, it is very easy to implement using this library. Let's view some examples.
# The way to import JUST the random module from the library is shown below.
from numpy import random
num = random.randint(10)                      # Returns random number from 0 to 10
print(num)
num_array = random.randint(10, size=(4))      # Returns 1D array containing 4 numbers between 0 to 10
print(num_array)
num_array_2D = random.randint(10, size=(2,2)) # Returns 2D array containing 4 numbers between 0 and 10
print(num_array_2D)
numfloat = random.rand()                      # Returns random number from 0 to 1
print(numfloat)
numfloat_array = random.rand(4)               # Returns 1D array containing 4 numbers between 0 and 1
print(numfloat_array)
numfloat_array_2D = random.rand(2,2)          # Returns 2D array containing 4 numbers between 0 and 1
print(numfloat_array_2D)
# %%

# %%
# Now the previous examples only generated new random numbers. But what if we want to randomly choose from data we
# already have? We can also do that with the random module. Since we also want to use other modules besides the
# random module, we will import the entire library.
from numpy import random
import numpy as np
array_1 = np.arange(10)                           # Create an array of data from 0 to 9
print(array_1)
new_array = random.choice(array_1)                # Return a random value from input array
print(new_array)
new_array_2D = random.choice(array_1, size=(2,2)) # Return an array filled with random values from input array
print(new_array_2D)
# %%

'''
If you would like to know more about NumPy and all the other things you can do with this library,
check out it's website and read through the documention. We have barely explored the tip of what
is possible with this library.
Website URL: https://numpy.org/doc/stable/reference/
'''

# Matplotlib - It's a library used for low level graph plotting. Using something like this would allow
#              the user to get some easy graphical representation of the data they are working with.
#              Most functionality that we are concerned with is going to be under the pyplot submodule.
#              If you are familiar with MATLAB
# Here is how to import the library for use in your code.
# import matplotlib
# Or if we only want the pyplot submodule. plt is the common alias used by most people.
# import matplotlib.pyplot as plt

# %%
# Let's create a simple plot to show how things work. We will need NumPy to create some data to plot and we will need matplotlib to plot the data.
# To view the plots that will be produced, go to the top right Plots panel. Each plot you create will be saved there for you to view.
import numpy as np
import matplotlib.pyplot as plt
time = np.arange(0,15,0.1)      # Create array containing our time values (0 to 15 seconds in 100ms intervals)
amplitude = np.sin(time)        # Take the sine of the time values
plt.plot(time, amplitude)       # Plot time vs amplitude
#plt.plot(time, amplitude, 'rx:')
plt.title('Sine Wave')          # Create a title for our plot
plt.xlabel('Time')              # Label our x-axis so we know it is time
plt.ylabel('Amplitude')         # Label our y-axis so we know it is amplitude
plt.grid(True, which='both')    # Create the grid lines on both x and y axis
plt.show()                      # Show the plot we created

# Now that we created a simple plot of a sine wave, let's change how the plot looks like.
# If we want, we can use something else other than the default line style and color for our plot.
# To customize the plot markings, you must add a format string as a third argument in the function.
# Comment out the first plt.plot() function and uncomment the second one to see the difference in visuals.
# There are other ways to change the line properties but they are for aesthetic/visual purposes only. For the full
# list of how you can customize your plot through the plot() function, please visit the link below.
# Website URL: https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot
# %%

# %%
# Now let's show off some other ways of plotting courtesy of the Matplotlib website.
# It is possible to create a plot using categorical variables instead of just numerical variables if need be.
# We will also show that it is possible to create subplots within each figure you create.
import matplotlib.pyplot as plt
names = ['group_a', 'group_b', 'group_c']
values = [1, 10, 100]
plt.figure(figsize=(9,3))                   # Configure our figure to accommodate the size of each subplot and ensure readabilty
plt.subplot(131)                            # Divide up the figure into a 1x3 grid and place next plot in first index
plt.bar(names, values)                      # Create a bar graph using original data
plt.subplot(132)                            # Keep figure divided into a 1x3 grid and place next plot in second index
plt.scatter(names, values)                  # Create a scatter plot using original data
plt.subplot(133)                            # Keep figure divided into a 1x3 grid and place next plot in third index
plt.plot(names, values)                     # Create a normal line plot using original data
plt.suptitle('Categorical Plotting')        # Create a centered title for entire figure instead of each plot individually
plt.show()                                  # Show the plot
# By using .figure(), we can change the width and height of the figure we are creating so make enough space
# for the other plots. The figure we created has a width of 9 and height of 3 in inches. If we decided to create
# a different plot that is not on the same window as the previous plot, we would need to invoke .figure() again.
# %%

# %%
# Let's go and see a little bit more about the different plots besides line plots.
# We will look into bar graphs first.
import matplotlib.pyplot as plt
x = ['Time', 'Interest', 'Will']                        # Create categories for the bar graph
y = [20, 30, 10]                                        # Give each category a value
plt.bar(x, y, color = "green", width = 0.5)             # Create a bar graph with a certain color and bar width
# plt.bar(x, y, color = "red", width = 0.1)             # Create a bar graph with a certain color and bar width
# plt.barh(x, y, color = "indigo", height = 0.5)        # Create a horizontal bar graph with a certain color and bar height
# plt.barh(x, y, color = "hotpink", height = 0.1)       # Create a horizontal bar graph with a certain color and bar height
plt.show()

# If you want, you don't have to add the color and width/height arguments if you want to stick to the default values of blue and 0.8
# Try out each line that has been commented out to see the different plots. If you want to change the color yourself,
# you need to use HTML color names or their corresponding Hex values.
# %%

# %%
# Let's look into scatter plots next.
# Let's use some functions from numpy to generate some data for us to work with.
from numpy import random
import matplotlib.pyplot as plt
x = random.randint(100, size = (10))        # Create an array full of random data
y = random.randint(100, size = (10))        # Do it again
plt.scatter(x, y)                           # Plot them against each other
x = random.randint(100, size = (10))        # Create a second set of random data
y = random.randint(100, size = (10))        # Do it again
plt.scatter(x, y)                           # Plot the second scatter plot on the same figure
plt.show()                                  # Show both plots on same figure, but different colors.

# You can also change the colors of the dots by adding color = "color you choose" as one of the arguments in plt.scatter()
# You have to HTML color names as well.
# You can also change the size of the dots, the transparency of the dots, or even change the dots to another shape if you want.
# If you want to see how, visit https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html#matplotlib.pyplot.scatter
# %%

'''
If you would like to know more about Matplotlib and all the other things you can do with this library,
check out it's website and read through the documention. We have barely explored one module of this library.
I highly recommend checking it out if you have to time for it.
Website URL: https://matplotlib.org/index.html
'''